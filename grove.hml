// Grove - Hemlock Playground Backend Server
// ==========================================
//
// Minimal HTTP server for the Hemlock Playground.
// Provides code execution via POST /execute endpoint.
//
// Usage:
//   hemlock grove.hml
//   GROVE_PORT=3000 hemlock grove.hml

import { TcpListener } from "@stdlib/net";
import { stringify, parse } from "@stdlib/json";
import { time_ms } from "@stdlib/time";
import { write_file, exists, remove_file, read_file, cwd } from "@stdlib/fs";
import { run_capture } from "@stdlib/shell";
import { getenv } from "@stdlib/env";

// =============================================================================
// Configuration
// =============================================================================

let CONFIG = {
    port: 8080,
    max_execution_time_ms: 10000,
    max_output_size: 65536,
    max_code_size: 102400,
    max_request_body_size: 131072,  // 128KB max request body
    temp_dir: "/tmp/hemlock-playground",
    hemlock_path: "hemlock",
    hemlockc_path: "hemlockc",
    hemlock_version: "unknown",
    cors_origin: "*",  // Configurable CORS origin
    rate_limit_requests: 60,  // Max requests per window
    rate_limit_window_ms: 60000  // 1 minute window
};

// =============================================================================
// Rate Limiting
// =============================================================================

// Simple in-memory rate limiter (per-IP tracking)
let rate_limit_store = {};

fn get_client_ip(req) {
    // Check X-Forwarded-For header first (for proxied requests)
    let forwarded = req["headers"]["x-forwarded-for"];
    if (forwarded != null && forwarded != "") {
        // Take the first IP in the list
        let comma_idx = forwarded.find(",");
        if (comma_idx != -1) {
            return trim(forwarded.substr(0, comma_idx));
        }
        return trim(forwarded);
    }
    // Fall back to direct connection (not available in current API, use placeholder)
    return "unknown";
}

fn check_rate_limit(client_ip) {
    let now = time_ms();
    let window_start = now - CONFIG["rate_limit_window_ms"];

    // Get or create entry for this IP
    let entry = rate_limit_store[client_ip];
    if (entry == null) {
        rate_limit_store[client_ip] = {
            requests: [now],
            blocked_until: 0
        };
        return true;
    }

    // Check if currently blocked
    if (entry["blocked_until"] > now) {
        return false;
    }

    // Filter out old requests outside the window
    let recent_requests = [];
    let requests = entry["requests"];
    for (let i = 0; i < requests.length; i = i + 1) {
        if (requests[i] > window_start) {
            recent_requests.push(requests[i]);
        }
    }

    // Check if over limit
    if (recent_requests.length >= CONFIG["rate_limit_requests"]) {
        // Block for the remainder of the window
        entry["blocked_until"] = now + CONFIG["rate_limit_window_ms"];
        entry["requests"] = recent_requests;
        return false;
    }

    // Add current request
    recent_requests.push(now);
    entry["requests"] = recent_requests;
    return true;
}

fn rate_limit_response() {
    return json_response(429, {
        error: "Too many requests",
        retry_after_seconds: CONFIG["rate_limit_window_ms"] / 1000
    });
}

// Periodically clean up old entries (call occasionally)
fn cleanup_rate_limit_store() {
    let now = time_ms();
    let window_start = now - CONFIG["rate_limit_window_ms"];
    let keys_to_remove = [];

    for (key in rate_limit_store) {
        let entry = rate_limit_store[key];
        // Remove entries with no recent requests and not blocked
        if (entry["blocked_until"] < now) {
            let has_recent = false;
            let requests = entry["requests"];
            for (let i = 0; i < requests.length; i = i + 1) {
                if (requests[i] > window_start) {
                    has_recent = true;
                    break;
                }
            }
            if (!has_recent) {
                keys_to_remove.push(key);
            }
        }
    }

    for (let i = 0; i < keys_to_remove.length; i = i + 1) {
        rate_limit_store[keys_to_remove[i]] = null;
    }
}

fn get_hemlock_version() {
    // Run hemlock --version and parse the output
    // Expected format: "Hemlock version X.Y.Z (built ...)"
    let result = run_capture([CONFIG["hemlock_path"], "--version"]);
    if (result["code"] != 0) {
        return "unknown";
    }

    let output = result["stdout"];
    // Find "version " and extract the version number
    let prefix = "version ";
    let start_idx = output.find(prefix);
    if (start_idx == -1) {
        return "unknown";
    }

    start_idx = start_idx + prefix.length;
    let end_idx = start_idx;

    // Read until we hit a space or end of line
    while (end_idx < output.length) {
        let ch = output.char_at(end_idx);
        if (ch == ' ' || ch == '\n' || ch == '\r') {
            break;
        }
        end_idx = end_idx + 1;
    }

    return output.substr(start_idx, end_idx - start_idx);
}

fn load_config() {
    let port = getenv("GROVE_PORT");
    if (port != null) {
        CONFIG["port"] = i32(port);
    }
    let hemlock = getenv("HEMLOCK_PATH");
    if (hemlock != null) {
        CONFIG["hemlock_path"] = hemlock;
    }
    let hemlockc = getenv("HEMLOCKC_PATH");
    if (hemlockc != null) {
        CONFIG["hemlockc_path"] = hemlockc;
    }

    // Configurable CORS origin (default: "*")
    let cors = getenv("GROVE_CORS_ORIGIN");
    if (cors != null) {
        CONFIG["cors_origin"] = cors;
    }

    // Configurable rate limiting
    let rate_limit = getenv("GROVE_RATE_LIMIT");
    if (rate_limit != null) {
        CONFIG["rate_limit_requests"] = i32(rate_limit);
    }

    // Get the actual hemlock version
    CONFIG["hemlock_version"] = get_hemlock_version();
}

// =============================================================================
// String Utilities
// =============================================================================

// Simple pseudo-random number generator (LCG)
let _rand_seed = 0;

fn init_random() {
    // Initialize seed from current time
    _rand_seed = time_ms();
}

fn random_int() {
    // Linear congruential generator
    _rand_seed = (_rand_seed * 1103515245 + 12345) % 2147483648;
    if (_rand_seed < 0) {
        _rand_seed = -_rand_seed;
    }
    return _rand_seed;
}

fn random_suffix(length) {
    let chars = "abcdefghijklmnopqrstuvwxyz0123456789";
    let result = "";
    for (let i = 0; i < length; i = i + 1) {
        let idx = random_int() % chars.length;
        result = result + chars.char_at(idx);
    }
    return result;
}

fn trim(s) {
    let start = 0;
    let end = s.length;
    while (start < end) {
        let ch = s.char_at(start);
        if (ch != ' ' && ch != '\t' && ch != '\n' && ch != '\r') {
            break;
        }
        start = start + 1;
    }
    while (end > start) {
        let ch = s.char_at(end - 1);
        if (ch != ' ' && ch != '\t' && ch != '\n' && ch != '\r') {
            break;
        }
        end = end - 1;
    }
    return s.substr(start, end - start);
}

fn to_lower(s) {
    let result = "";
    for (let i = 0; i < s.length; i = i + 1) {
        let ch = s.char_at(i);
        let code: i32 = ch;
        if (code >= 65 && code <= 90) {
            result = result + rune_to_string(code + 32);
        } else {
            result = result + rune_to_string(ch);
        }
    }
    return result;
}

fn rune_to_string(code) {
    let r: rune = code;
    return "" + r;
}

// Calculate UTF-8 byte length of a string
fn byte_length(s) {
    let len = 0;
    for (let i = 0; i < s.length; i = i + 1) {
        let code: i32 = s.char_at(i);
        if (code < 128) {
            len = len + 1;
        } else if (code < 2048) {
            len = len + 2;
        } else if (code < 65536) {
            len = len + 3;
        } else {
            len = len + 4;
        }
    }
    return len;
}

// =============================================================================
// HTTP Parsing
// =============================================================================

fn parse_request(data) {
    let lines = data.split("\r\n");
    if (lines.length == 0) {
        return null;
    }

    // Parse request line: "GET /path HTTP/1.1"
    let request_line = lines[0];
    let parts = request_line.split(" ");
    if (parts.length < 2) {
        return null;
    }

    let method = parts[0];
    let full_url = parts[1];

    // Split path and query string
    let path = full_url;
    let query = "";
    let q_idx = full_url.find("?");
    if (q_idx != -1) {
        path = full_url.substr(0, q_idx);
        query = full_url.substr(q_idx + 1, full_url.length - q_idx - 1);
    }

    // Parse headers
    let headers = {};
    let body_start = -1;
    for (let i = 1; i < lines.length; i = i + 1) {
        let line = lines[i];
        if (line == "") {
            body_start = i + 1;
            break;
        }
        let colon_idx = line.find(":");
        if (colon_idx != -1) {
            let name = to_lower(trim(line.substr(0, colon_idx)));
            let value = trim(line.substr(colon_idx + 1, line.length - colon_idx - 1));
            headers[name] = value;
        }
    }

    // Get body
    let body = "";
    if (body_start != -1 && body_start < lines.length) {
        let body_lines = [];
        for (let i = body_start; i < lines.length; i = i + 1) {
            body_lines.push(lines[i]);
        }
        body = body_lines.join("\r\n");
    }

    return {
        method: method,
        path: path,
        query: query,
        headers: headers,
        body: body
    };
}

// =============================================================================
// HTTP Response Building
// =============================================================================

fn build_response(status, status_text, content_type, body) {
    let response = `HTTP/1.1 ${status} ${status_text}\r\n`;
    response = response + `Content-Type: ${content_type}\r\n`;
    response = response + `Content-Length: ${byte_length(body)}\r\n`;
    response = response + `Access-Control-Allow-Origin: ${CONFIG["cors_origin"]}\r\n`;
    response = response + "Access-Control-Allow-Methods: GET, POST, OPTIONS\r\n";
    response = response + "Access-Control-Allow-Headers: Content-Type\r\n";
    response = response + "Connection: close\r\n";
    response = response + "\r\n";
    response = response + body;
    return response;
}

fn json_response(status, data) {
    let body = stringify(data);
    let status_text = "OK";
    if (status == 400) { status_text = "Bad Request"; }
    if (status == 404) { status_text = "Not Found"; }
    if (status == 413) { status_text = "Payload Too Large"; }
    if (status == 429) { status_text = "Too Many Requests"; }
    if (status == 500) { status_text = "Internal Server Error"; }
    return build_response(status, status_text, "application/json", body);
}

fn html_response(status, body) {
    return build_response(status, "OK", "text/html; charset=utf-8", body);
}

// =============================================================================
// Code Execution
// =============================================================================

fn ensure_temp_dir() {
    if (!exists(CONFIG["temp_dir"])) {
        run_capture(["mkdir", "-p", CONFIG["temp_dir"]]);
    }
}

fn execute_code(code, stdin_data) {
    let start_time = time_ms();

    // Validate code size
    if (code.length > CONFIG["max_code_size"]) {
        return {
            success: false,
            stdout: "",
            stderr: "Error: Code exceeds maximum size limit (100KB)",
            exit_code: 1,
            execution_time_ms: 0,
            timed_out: false,
            truncated: false
        };
    }

    // Create temp file with random suffix to prevent predictable filenames
    ensure_temp_dir();
    let ts = time_ms();
    let rand = random_suffix(12);
    let temp_file = `${CONFIG["temp_dir"]}/exec_${ts}_${rand}.hml`;
    write_file(temp_file, code);

    // Create stdin file if stdin data is provided
    let stdin_file = null;
    if (stdin_data != null && stdin_data != "") {
        stdin_file = `${CONFIG["temp_dir"]}/stdin_${ts}_${rand}.txt`;
        write_file(stdin_file, stdin_data);
    }

    // Execute with sandbox using timeout command
    let timeout_sec = CONFIG["max_execution_time_ms"] / 1000;
    let result = null;

    if (stdin_file != null) {
        // Use array-based execution with stdin file via --stdin flag if available
        // For now, use shell for stdin redirection (paths are server-controlled, safe)
        result = run_capture([
            "sh", "-c",
            `timeout ${timeout_sec} "${CONFIG["hemlock_path"]}" --sandbox "${temp_file}" < "${stdin_file}" 2>&1`
        ]);
    } else {
        // Use shell mode for stderr redirection (run_capture doesn't capture stderr in array mode)
        // Paths are server-controlled and quoted, so this is safe
        result = run_capture([
            "sh", "-c",
            `timeout ${timeout_sec} "${CONFIG["hemlock_path"]}" --sandbox "${temp_file}" 2>&1`
        ]);
    }
    let execution_time = time_ms() - start_time;

    // Check if timed out (exit code 124 from timeout command)
    let timed_out = result["code"] == 124;

    // Truncate output if too large
    let stdout = result["stdout"];
    let stderr = result["stderr"];
    let truncated = false;

    // Combine stdout and stderr for consistent output
    if (stderr != "" && stderr != null) {
        stdout = stdout + stderr;
    }

    if (stdout.length > CONFIG["max_output_size"]) {
        stdout = stdout.substr(0, CONFIG["max_output_size"]);
        truncated = true;
    }

    // Cleanup temp files
    if (exists(temp_file)) {
        remove_file(temp_file);
    }
    if (stdin_file != null && exists(stdin_file)) {
        remove_file(stdin_file);
    }

    return {
        success: result["code"] == 0,
        stdout: stdout,
        stderr: "",
        exit_code: result["code"],
        execution_time_ms: execution_time,
        timed_out: timed_out,
        truncated: truncated
    };
}

// =============================================================================
// Request Handlers
// =============================================================================

fn handle_health() {
    return json_response(200, {
        status: "ok",
        hemlock_version: CONFIG["hemlock_version"]
    });
}

fn handle_version() {
    return json_response(200, {
        api_version: "1.0.0",
        hemlock_version: CONFIG["hemlock_version"],
        max_execution_time: CONFIG["max_execution_time_ms"] / 1000,
        max_output_size: CONFIG["max_output_size"]
    });
}

fn handle_check(body) {
    // Parse JSON body
    let data = null;
    try {
        data = parse(body);
    } catch (e) {
        return json_response(400, {
            valid: false,
            errors: "Invalid JSON body"
        });
    }

    // Get code from body
    let code = data["code"];
    if (code == null || code == "") {
        return json_response(400, {
            valid: false,
            errors: "Missing 'code' field"
        });
    }

    // Validate code size
    if (code.length > CONFIG["max_code_size"]) {
        return json_response(400, {
            valid: false,
            errors: "Code exceeds maximum size limit (100KB)"
        });
    }

    // Create temp file with random suffix to prevent predictable filenames
    ensure_temp_dir();
    let ts = time_ms();
    let rand = random_suffix(12);
    let temp_file = `${CONFIG["temp_dir"]}/check_${ts}_${rand}.hml`;
    write_file(temp_file, code);

    // Run hemlockc --check with stderr capture
    // Paths are server-controlled and quoted, so this is safe
    let result = run_capture([
        "sh", "-c",
        `"${CONFIG["hemlockc_path"]}" --check "${temp_file}" 2>&1`
    ]);

    // Cleanup temp file
    if (exists(temp_file)) {
        remove_file(temp_file);
    }

    // Check result
    let valid = result["code"] == 0;
    let errors = "";

    // On failure, get error message from stdout or stderr
    if (!valid) {
        errors = result["stdout"];
        if ((errors == "" || errors == null) && result["stderr"] != null) {
            errors = result["stderr"];
        }
        // Clean up temp file path from error messages for cleaner output
        if (errors != "" && errors != null) {
            errors = errors.split(temp_file).join("main.hml");
        }
    }

    return json_response(200, {
        valid: valid,
        errors: errors
    });
}

fn handle_execute(body) {
    // Parse JSON body
    let data = null;
    try {
        data = parse(body);
    } catch (e) {
        return json_response(400, {
            success: false,
            error: "Invalid JSON body"
        });
    }

    // Get code from body
    let code = data["code"];
    if (code == null || code == "") {
        return json_response(400, {
            success: false,
            error: "Missing 'code' field"
        });
    }

    // Get optional stdin data
    let stdin_data = data["stdin"];

    // Execute and return result
    let result = execute_code(code, stdin_data);
    return json_response(200, result);
}

fn handle_options() {
    // CORS preflight
    return build_response(204, "No Content", "text/plain", "");
}

fn handle_index() {
    // Serve playground.html from current directory
    let html_path = `${cwd()}/playground.html`;
    if (!exists(html_path)) {
        return json_response(404, {
            error: "playground.html not found",
            path: html_path
        });
    }
    let content = read_file(html_path);
    return build_response(200, "OK", "text/html; charset=utf-8", content);
}

fn handle_not_found(path) {
    return json_response(404, {
        error: "Not found",
        path: path
    });
}

// =============================================================================
// Connection Handler
// =============================================================================

// Helper to convert raw bytes to string
fn bytes_to_string(raw_data) {
    let result = "";
    for (let i = 0; i < raw_data.length; i = i + 1) {
        let b: i32 = raw_data[i];
        result = result + rune_to_string(b);
    }
    return result;
}

// Parse headers from partial data to find Content-Length
fn find_content_length(data) {
    let header_end = data.find("\r\n\r\n");
    if (header_end == -1) {
        return -1;  // Headers not complete yet
    }

    let headers_str = to_lower(data.substr(0, header_end));
    let cl_idx = headers_str.find("content-length:");
    if (cl_idx == -1) {
        return 0;  // No content-length header, assume no body
    }

    // Find the value after "content-length:"
    let start = cl_idx + 15;  // Length of "content-length:"
    while (start < headers_str.length && headers_str.char_at(start) == ' ') {
        start = start + 1;
    }

    let end = start;
    while (end < headers_str.length) {
        let ch = headers_str.char_at(end);
        if (ch == '\r' || ch == '\n') {
            break;
        }
        end = end + 1;
    }

    let value_str = headers_str.substr(start, end - start);
    return i32(value_str);
}

// Counter for periodic cleanup
let _request_count = 0;

fn handle_connection(stream) {
    try {
        // Read initial data
        let raw_data = stream.read(65536);
        if (raw_data == null || raw_data.length == 0) {
            stream.close();
            return;
        }

        // Convert buffer to string
        let data = bytes_to_string(raw_data);

        if (data == "") {
            stream.close();
            return;
        }

        // Check if we need to read more data based on Content-Length
        let header_end = data.find("\r\n\r\n");
        if (header_end != -1) {
            let content_length = find_content_length(data);

            // Validate request body size before reading more data
            if (content_length > CONFIG["max_request_body_size"]) {
                let response = json_response(413, {
                    error: "Request body too large",
                    max_size: CONFIG["max_request_body_size"]
                });
                stream.write(response);
                stream.close();
                return;
            }

            if (content_length > 0) {
                let body_start = header_end + 4;  // After \r\n\r\n
                let current_body_len = byte_length(data.substr(body_start, data.length - body_start));

                // Keep reading until we have the complete body
                while (current_body_len < content_length) {
                    let more_data = stream.read(65536);
                    if (more_data == null || more_data.length == 0) {
                        break;
                    }
                    data = data + bytes_to_string(more_data);
                    current_body_len = byte_length(data.substr(body_start, data.length - body_start));
                }
            }
        }

        // Parse HTTP request
        let req = parse_request(data);
        if (req == null) {
            stream.close();
            return;
        }

        // Apply rate limiting (skip for health checks)
        let path = req["path"];
        if (path != "/health") {
            let client_ip = get_client_ip(req);
            if (!check_rate_limit(client_ip)) {
                let response = rate_limit_response();
                stream.write(response);
                stream.close();
                return;
            }
        }

        // Periodic cleanup of rate limit store (every 100 requests)
        _request_count = _request_count + 1;
        if (_request_count >= 100) {
            cleanup_rate_limit_store();
            _request_count = 0;
        }

        // Log request
        print(`${req["method"]} ${path}`);

        // Route request
        let response = "";
        let method = req["method"];

        if (method == "OPTIONS") {
            response = handle_options();
        } else if ((path == "/" || path == "/index.html") && method == "GET") {
            response = handle_index();
        } else if (path == "/health" && method == "GET") {
            response = handle_health();
        } else if (path == "/version" && method == "GET") {
            response = handle_version();
        } else if (path == "/execute" && method == "POST") {
            response = handle_execute(req["body"]);
        } else if (path == "/check" && method == "POST") {
            response = handle_check(req["body"]);
        } else {
            response = handle_not_found(path);
        }

        // Send response
        stream.write(response);
        stream.close();

    } catch (e) {
        print(`Error handling connection: ${e}`);
        try {
            stream.close();
        } catch (e2) {
            // Ignore close errors
        }
    }
}

// =============================================================================
// Main Server
// =============================================================================

fn main() {
    load_config();
    init_random();

    print("Grove - Hemlock Playground Server");
    print("==================================");
    print(`Listening on http://0.0.0.0:${CONFIG["port"]}`);
    print("");
    print("Endpoints:");
    print("  GET  /health  - Health check");
    print("  GET  /version - Version info");
    print("  POST /check   - Type check code (hemlockc)");
    print("  POST /execute - Execute code");
    print("");
    print("Press Ctrl+C to stop.");
    print("");

    // Create TCP listener
    let listener = null;
    try {
        listener = TcpListener("0.0.0.0", CONFIG["port"]);
    } catch (e) {
        print(`Error: Failed to start server on port ${CONFIG["port"]}`);
        print(`${e}`);
        return;
    }

    // Accept connections
    while (true) {
        let stream = listener.accept();
        handle_connection(stream);
    }
}

main();
