// Grove - Hemlock Playground Backend Server
// ==========================================
//
// Minimal HTTP server for the Hemlock Playground.
// Provides code execution via POST /execute endpoint.
//
// Usage:
//   hemlock grove.hml
//   GROVE_PORT=3000 hemlock grove.hml

import { TcpListener } from "@stdlib/net";
import { stringify, parse } from "@stdlib/json";
import { time_ms } from "@stdlib/time";
import { write_file, exists, remove_file, read_file, cwd } from "@stdlib/fs";
import { run_capture } from "@stdlib/shell";
import { getenv } from "@stdlib/env";

// =============================================================================
// Configuration
// =============================================================================

let CONFIG = {
    port: 8080,
    max_execution_time_ms: 10000,
    max_output_size: 65536,
    max_code_size: 102400,
    temp_dir: "/tmp/hemlock-playground",
    hemlock_path: "hemlock",
    hemlockc_path: "hemlockc",
    hemlock_version: "unknown"
};

fn get_hemlock_version() {
    // Run hemlock --version and parse the output
    // Expected format: "Hemlock version X.Y.Z (built ...)"
    let result = run_capture([CONFIG["hemlock_path"], "--version"]);
    if (result["code"] != 0) {
        return "unknown";
    }

    let output = result["stdout"];
    // Find "version " and extract the version number
    let prefix = "version ";
    let start_idx = output.find(prefix);
    if (start_idx == -1) {
        return "unknown";
    }

    start_idx = start_idx + prefix.length;
    let end_idx = start_idx;

    // Read until we hit a space or end of line
    while (end_idx < output.length) {
        let ch = output.char_at(end_idx);
        if (ch == ' ' || ch == '\n' || ch == '\r') {
            break;
        }
        end_idx = end_idx + 1;
    }

    return output.substr(start_idx, end_idx - start_idx);
}

fn load_config() {
    let port = getenv("GROVE_PORT");
    if (port != null) {
        CONFIG["port"] = i32(port);
    }
    let hemlock = getenv("HEMLOCK_PATH");
    if (hemlock != null) {
        CONFIG["hemlock_path"] = hemlock;
    }
    let hemlockc = getenv("HEMLOCKC_PATH");
    if (hemlockc != null) {
        CONFIG["hemlockc_path"] = hemlockc;
    }

    // Get the actual hemlock version
    CONFIG["hemlock_version"] = get_hemlock_version();
}

// =============================================================================
// String Utilities
// =============================================================================

fn trim(s) {
    let start = 0;
    let end = s.length;
    while (start < end) {
        let ch = s.char_at(start);
        if (ch != ' ' && ch != '\t' && ch != '\n' && ch != '\r') {
            break;
        }
        start = start + 1;
    }
    while (end > start) {
        let ch = s.char_at(end - 1);
        if (ch != ' ' && ch != '\t' && ch != '\n' && ch != '\r') {
            break;
        }
        end = end - 1;
    }
    return s.substr(start, end - start);
}

fn to_lower(s) {
    let result = "";
    for (let i = 0; i < s.length; i = i + 1) {
        let ch = s.char_at(i);
        let code: i32 = ch;
        if (code >= 65 && code <= 90) {
            result = result + rune_to_string(code + 32);
        } else {
            result = result + rune_to_string(ch);
        }
    }
    return result;
}

fn rune_to_string(code) {
    let r: rune = code;
    return "" + r;
}

// Calculate UTF-8 byte length of a string
fn byte_length(s) {
    let len = 0;
    for (let i = 0; i < s.length; i = i + 1) {
        let code: i32 = s.char_at(i);
        if (code < 128) {
            len = len + 1;
        } else if (code < 2048) {
            len = len + 2;
        } else if (code < 65536) {
            len = len + 3;
        } else {
            len = len + 4;
        }
    }
    return len;
}

// =============================================================================
// HTTP Parsing
// =============================================================================

fn parse_request(data) {
    let lines = data.split("\r\n");
    if (lines.length == 0) {
        return null;
    }

    // Parse request line: "GET /path HTTP/1.1"
    let request_line = lines[0];
    let parts = request_line.split(" ");
    if (parts.length < 2) {
        return null;
    }

    let method = parts[0];
    let full_url = parts[1];

    // Split path and query string
    let path = full_url;
    let query = "";
    let q_idx = full_url.find("?");
    if (q_idx != -1) {
        path = full_url.substr(0, q_idx);
        query = full_url.substr(q_idx + 1, full_url.length - q_idx - 1);
    }

    // Parse headers
    let headers = {};
    let body_start = -1;
    for (let i = 1; i < lines.length; i = i + 1) {
        let line = lines[i];
        if (line == "") {
            body_start = i + 1;
            break;
        }
        let colon_idx = line.find(":");
        if (colon_idx != -1) {
            let name = to_lower(trim(line.substr(0, colon_idx)));
            let value = trim(line.substr(colon_idx + 1, line.length - colon_idx - 1));
            headers[name] = value;
        }
    }

    // Get body
    let body = "";
    if (body_start != -1 && body_start < lines.length) {
        let body_lines = [];
        for (let i = body_start; i < lines.length; i = i + 1) {
            body_lines.push(lines[i]);
        }
        body = body_lines.join("\r\n");
    }

    return {
        method: method,
        path: path,
        query: query,
        headers: headers,
        body: body
    };
}

// =============================================================================
// HTTP Response Building
// =============================================================================

fn build_response(status, status_text, content_type, body) {
    let response = `HTTP/1.1 ${status} ${status_text}\r\n`;
    response = response + `Content-Type: ${content_type}\r\n`;
    response = response + `Content-Length: ${byte_length(body)}\r\n`;
    response = response + "Access-Control-Allow-Origin: *\r\n";
    response = response + "Access-Control-Allow-Methods: GET, POST, OPTIONS\r\n";
    response = response + "Access-Control-Allow-Headers: Content-Type\r\n";
    response = response + "Connection: close\r\n";
    response = response + "\r\n";
    response = response + body;
    return response;
}

fn json_response(status, data) {
    let body = stringify(data);
    let status_text = "OK";
    if (status == 400) { status_text = "Bad Request"; }
    if (status == 404) { status_text = "Not Found"; }
    if (status == 500) { status_text = "Internal Server Error"; }
    return build_response(status, status_text, "application/json", body);
}

fn html_response(status, body) {
    return build_response(status, "OK", "text/html; charset=utf-8", body);
}

// =============================================================================
// Code Execution
// =============================================================================

fn ensure_temp_dir() {
    if (!exists(CONFIG["temp_dir"])) {
        run_capture(["mkdir", "-p", CONFIG["temp_dir"]]);
    }
}

fn execute_code(code, stdin_data) {
    let start_time = time_ms();

    // Validate code size
    if (code.length > CONFIG["max_code_size"]) {
        return {
            success: false,
            stdout: "",
            stderr: "Error: Code exceeds maximum size limit (100KB)",
            exit_code: 1,
            execution_time_ms: 0,
            timed_out: false,
            truncated: false
        };
    }

    // Create temp file
    ensure_temp_dir();
    let ts = time_ms();
    let temp_file = `${CONFIG["temp_dir"]}/exec_${ts}.hml`;
    write_file(temp_file, code);

    // Create stdin file if stdin data is provided
    let stdin_file = null;
    if (stdin_data != null && stdin_data != "") {
        stdin_file = `${CONFIG["temp_dir"]}/stdin_${ts}.txt`;
        write_file(stdin_file, stdin_data);
    }

    // Execute with sandbox using timeout command
    // Use shell to enable stdin redirection when needed
    let timeout_sec = CONFIG["max_execution_time_ms"] / 1000;
    let result = null;

    if (stdin_file != null) {
        // Use shell for stdin redirection
        let cmd = `timeout ${timeout_sec} ${CONFIG["hemlock_path"]} --sandbox ${temp_file} < ${stdin_file}`;
        result = run_capture(["sh", "-c", cmd]);
    } else {
        // No stdin, use array form (safer)
        result = run_capture([
            "timeout",
            `${timeout_sec}`,
            CONFIG["hemlock_path"],
            "--sandbox",
            temp_file
        ]);
    }
    let execution_time = time_ms() - start_time;

    // Check if timed out (exit code 124 from timeout command)
    let timed_out = result["code"] == 124;

    // Truncate output if too large
    let stdout = result["stdout"];
    let truncated = false;
    if (stdout.length > CONFIG["max_output_size"]) {
        stdout = stdout.substr(0, CONFIG["max_output_size"]);
        truncated = true;
    }

    // Cleanup temp files
    if (exists(temp_file)) {
        remove_file(temp_file);
    }
    if (stdin_file != null && exists(stdin_file)) {
        remove_file(stdin_file);
    }

    return {
        success: result["code"] == 0,
        stdout: stdout,
        stderr: result["stderr"],
        exit_code: result["code"],
        execution_time_ms: execution_time,
        timed_out: timed_out,
        truncated: truncated
    };
}

// =============================================================================
// Request Handlers
// =============================================================================

fn handle_health() {
    return json_response(200, {
        status: "ok",
        hemlock_version: CONFIG["hemlock_version"]
    });
}

fn handle_version() {
    return json_response(200, {
        api_version: "1.0.0",
        hemlock_version: CONFIG["hemlock_version"],
        max_execution_time: CONFIG["max_execution_time_ms"] / 1000,
        max_output_size: CONFIG["max_output_size"]
    });
}

fn handle_check(body) {
    // Parse JSON body
    let data = null;
    try {
        data = parse(body);
    } catch (e) {
        return json_response(400, {
            valid: false,
            errors: "Invalid JSON body"
        });
    }

    // Get code from body
    let code = data["code"];
    if (code == null || code == "") {
        return json_response(400, {
            valid: false,
            errors: "Missing 'code' field"
        });
    }

    // Validate code size
    if (code.length > CONFIG["max_code_size"]) {
        return json_response(400, {
            valid: false,
            errors: "Code exceeds maximum size limit (100KB)"
        });
    }

    // Create temp file
    ensure_temp_dir();
    let temp_file = `${CONFIG["temp_dir"]}/check_${time_ms()}.hml`;
    write_file(temp_file, code);

    // Run hemlockc --check with stderr redirected to stdout
    // Using shell mode because run_capture doesn't capture stderr in fork/exec mode
    let cmd = `${CONFIG["hemlockc_path"]} --check '${temp_file}' 2>&1`;
    let result = run_capture(cmd);

    // Cleanup temp file
    if (exists(temp_file)) {
        remove_file(temp_file);
    }

    // Check result - errors are in stdout due to 2>&1 redirect
    let valid = result["code"] == 0;
    let errors = "";

    // On failure, get error message from stdout (due to stderr redirect)
    if (!valid) {
        errors = result["stdout"];
        // Clean up temp file path from error messages for cleaner output
        if (errors != "") {
            errors = errors.split(temp_file).join("main.hml");
        }
    }

    return json_response(200, {
        valid: valid,
        errors: errors
    });
}

fn handle_execute(body) {
    // Parse JSON body
    let data = null;
    try {
        data = parse(body);
    } catch (e) {
        return json_response(400, {
            success: false,
            error: "Invalid JSON body"
        });
    }

    // Get code from body
    let code = data["code"];
    if (code == null || code == "") {
        return json_response(400, {
            success: false,
            error: "Missing 'code' field"
        });
    }

    // Get optional stdin data
    let stdin_data = data["stdin"];

    // Execute and return result
    let result = execute_code(code, stdin_data);
    return json_response(200, result);
}

fn handle_options() {
    // CORS preflight
    return build_response(204, "No Content", "text/plain", "");
}

fn handle_index() {
    // Serve playground.html from current directory
    let html_path = `${cwd()}/playground.html`;
    if (!exists(html_path)) {
        return json_response(404, {
            error: "playground.html not found",
            path: html_path
        });
    }
    let content = read_file(html_path);
    return build_response(200, "OK", "text/html; charset=utf-8", content);
}

fn handle_not_found(path) {
    return json_response(404, {
        error: "Not found",
        path: path
    });
}

// =============================================================================
// Connection Handler
// =============================================================================

// Helper to convert raw bytes to string
fn bytes_to_string(raw_data) {
    let result = "";
    for (let i = 0; i < raw_data.length; i = i + 1) {
        let b: i32 = raw_data[i];
        result = result + rune_to_string(b);
    }
    return result;
}

// Parse headers from partial data to find Content-Length
fn find_content_length(data) {
    let header_end = data.find("\r\n\r\n");
    if (header_end == -1) {
        return -1;  // Headers not complete yet
    }

    let headers_str = to_lower(data.substr(0, header_end));
    let cl_idx = headers_str.find("content-length:");
    if (cl_idx == -1) {
        return 0;  // No content-length header, assume no body
    }

    // Find the value after "content-length:"
    let start = cl_idx + 15;  // Length of "content-length:"
    while (start < headers_str.length && headers_str.char_at(start) == ' ') {
        start = start + 1;
    }

    let end = start;
    while (end < headers_str.length) {
        let ch = headers_str.char_at(end);
        if (ch == '\r' || ch == '\n') {
            break;
        }
        end = end + 1;
    }

    let value_str = headers_str.substr(start, end - start);
    return i32(value_str);
}

fn handle_connection(stream) {
    try {
        // Read initial data
        let raw_data = stream.read(65536);
        if (raw_data == null || raw_data.length == 0) {
            stream.close();
            return;
        }

        // Convert buffer to string
        let data = bytes_to_string(raw_data);

        if (data == "") {
            stream.close();
            return;
        }

        // Check if we need to read more data based on Content-Length
        let header_end = data.find("\r\n\r\n");
        if (header_end != -1) {
            let content_length = find_content_length(data);
            if (content_length > 0) {
                let body_start = header_end + 4;  // After \r\n\r\n
                let current_body_len = byte_length(data.substr(body_start, data.length - body_start));

                // Keep reading until we have the complete body
                while (current_body_len < content_length) {
                    let more_data = stream.read(65536);
                    if (more_data == null || more_data.length == 0) {
                        break;
                    }
                    data = data + bytes_to_string(more_data);
                    current_body_len = byte_length(data.substr(body_start, data.length - body_start));
                }
            }
        }

        // Parse HTTP request
        let req = parse_request(data);
        if (req == null) {
            stream.close();
            return;
        }

        // Log request
        print(`${req["method"]} ${req["path"]}`);

        // Route request
        let response = "";
        let method = req["method"];
        let path = req["path"];

        if (method == "OPTIONS") {
            response = handle_options();
        } else if ((path == "/" || path == "/index.html") && method == "GET") {
            response = handle_index();
        } else if (path == "/health" && method == "GET") {
            response = handle_health();
        } else if (path == "/version" && method == "GET") {
            response = handle_version();
        } else if (path == "/execute" && method == "POST") {
            response = handle_execute(req["body"]);
        } else if (path == "/check" && method == "POST") {
            response = handle_check(req["body"]);
        } else {
            response = handle_not_found(path);
        }

        // Send response
        stream.write(response);
        stream.close();

    } catch (e) {
        print(`Error handling connection: ${e}`);
        try {
            stream.close();
        } catch (e2) {
            // Ignore close errors
        }
    }
}

// =============================================================================
// Main Server
// =============================================================================

fn main() {
    load_config();

    print("Grove - Hemlock Playground Server");
    print("==================================");
    print(`Listening on http://0.0.0.0:${CONFIG["port"]}`);
    print("");
    print("Endpoints:");
    print("  GET  /health  - Health check");
    print("  GET  /version - Version info");
    print("  POST /check   - Type check code (hemlockc)");
    print("  POST /execute - Execute code");
    print("");
    print("Press Ctrl+C to stop.");
    print("");

    // Create TCP listener
    let listener = null;
    try {
        listener = TcpListener("0.0.0.0", CONFIG["port"]);
    } catch (e) {
        print(`Error: Failed to start server on port ${CONFIG["port"]}`);
        print(`${e}`);
        return;
    }

    // Accept connections
    while (true) {
        let stream = listener.accept();
        handle_connection(stream);
    }
}

main();
